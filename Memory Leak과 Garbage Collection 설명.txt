Memory Leak과 Garbage Collection 설명

✅ 1. 메모리 누수 (Memory Leak)
✔ 정의:
할당된 메모리가 더 이상 사용되지 않는데도 해제되지 않아 시스템 자원을 계속 차지하고 있는 상태입니다.

특히 힙 영역에서 발생.

사용자가 new, malloc 등으로 메모리를 할당했지만, 더 이상 참조하지 않으면서도 해제하지 않은 경우 발생.

✔ 왜 문제일까?
사용 가능한 메모리가 줄어듦 → 프로그램 속도 저하, 충돌, 시스템 과부하 발생.

**장기 실행 프로그램(예: 서버)**에서 특히 심각.

✔ 예시 (C/C++)
c
복사
편집
int* p = malloc(sizeof(int));  // 메모리 할당
*p = 10;
// free(p); ← 해제를 안 하면 메모리 누수 발생
✔ C#에서도 발생할 수 있음!
C#은 가비지 컬렉션이 있지만, 이벤트 핸들러, unmanaged 자원 등은 직접 해제해줘야 하므로 다음과 같은 상황에서 누수가 발생할 수 있어요.

csharp
복사
편집
public class MyClass
{
    public event EventHandler SomethingHappened;
}

// 구독 후 구독 해제 안 하면 MyClass 객체가 해제되지 않음 → 누수
✅ 2. 가비지 컬렉션 (Garbage Collection)
✔ 정의:
더 이상 사용되지 않는 메모리를 자동으로 찾아서 해제하는 기능입니다.
C#, Java 같은 언어는 **가비지 컬렉터(GC)**가 내장되어 있어 개발자가 직접 메모리를 해제하지 않아도 됩니다.

✔ 어떻게 작동하나?
GC가 실행됨 (명시적 or 주기적)

**도달할 수 없는 객체(참조 없음)**를 탐색

해당 객체를 메모리에서 제거

✔ C#에서의 예시:
csharp
복사
편집
class Car
{
    public string Name { get; set; }
}

void Test()
{
    Car car = new Car();
    car = null;  // 더 이상 참조하지 않음 → GC 대상
    // GC가 이 객체를 나중에 정리함
}
✔ 가비지 컬렉션의 장점
개발자가 메모리 해제를 수동으로 관리하지 않아도 됨

메모리 누수 가능성 ↓ (단, 완전한 방어는 아님)

프로그램 안정성 ↑

✔ 단점
GC 실행 시 성능 저하 가능성 있음 (GC는 CPU 자원을 사용함)

실시간 처리에 민감한 프로그램(게임, 산업 제어 등)에서는 부적합할 수도 있음

✅ 비교 요약
항목	메모리 누수	가비지 컬렉션
개념	해제 안 된 메모리가 남는 현상	안 쓰는 메모리를 자동으로 해제
언어	C, C++ (수동 관리)	C#, Java 등 (자동 관리)
원인	free, Dispose 안 함	해당 없음 (GC가 관리)
해결법	수동 해제 (free, Dispose)	GC 튜닝, 메모리 참조 끊기
문제 발생 시점	예측 가능 (코드에 따라)	예측 불가 (GC 타이밍은 자동)

필요하다면 C#에서 IDisposable / using 문법, GC 강제 호출 방법, 메모리 누수 탐지 툴까지도 설명드릴 수 있어요.
더 알고 싶은 부분이 있나요?